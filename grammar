# Lines starting with # are comments
# Capitcalize names are tokens generated by the scanner
# This grammar is copied from another grammar I found online
# but currently I don't have its source, but I will include it anyway

# Items inside double quotes are type literally when writing regular expression
# ITEM? : ITEM is optional
# ITEM* : ITEM occurrs zero or more times
# ITEM+ : ITEM occurrs one or more times

# An arbitrary `RegULAR expRESSION` (hence the name `Regexp`)
Regexp => Concatenation ( "|" Regexp )*
# An arbitrary regular expression is either:
# - Concatentation of other regular expressions, like: `a(a|b)(c*z).a` or just `.` or `x`
# - Alternation of other regular expressions, like: a|(bc)|ccc
# THUS, Alternation has lower precedence than concatentation

# An expression of the form: E1E2...E_n
# placing expressions adjacent to one another with no separators
# something like `...(a+)(b(c|c))a.b.c.`
Concatenation => Primary+

Primary => EMPTY_STRING | QuantifiedExpression
# `EMPTY_STRING` is a token generated by the scanner

QuantifiedExpression => ( Match | Group ) Quantifier?

Quantifier => ZeroOrOne | ZeroOrMore | OneOrMore

ZeroOrOne => "?"

ZeroOrMore => "*"

OneOrMore => "+"

# An expression of the form: (E)
# E is an arbitray expression
# something like (abc*)
Group => "(" Regexp ")"

Match => MatchCharacter | MatchAnyCharacter

# Token (CHARACTER) represents an arbitrary non-metacharacter
# to match a literal metacharacter escape it with slash \
# to match a literal | use \|
MatchCharacter => CHARACTER
# `CHARACTER` is a token generated by the scanner

# Dot expression `.` matches any single character
MatchAnyCharacter => "."
