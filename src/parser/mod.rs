// Parser module
// Take Tokens generated by the scanner and structure them

// Syntax tree structs
pub mod syntax_tree;

use crate::scanner::{tokens::*, Scanner};
use crate::{format_error, report_fatal_error};
use std::sync::{Arc, RwLock};
use syntax_tree::*;

#[allow(dead_code)]
// Mark where to a grouping begins
enum GroupingMark {
    // There is a ( in index `position` in source string
    Group { position: usize },
}

pub struct Parser {
    // Tokens stream
    scanner: Scanner,
    // currently (`processed` or `to be processed`) token
    current: Option<Token>,
    // -------------------- NOTE --------------------
    // AFTER PARSING AN ARBITRARY EXPRESSION, FIELD `current` MUST
    // POINT TO THE VERY FIRST CHARACTER (IF ANY, OR Empty token)
    // AFTER THE MOST RECENTLY PARSED EXPRESSION
    // ----------------------------------------------

    // marks stack
    // we need a stack because groups (...) can nest
    grouping_marks: Vec<GroupingMark>,
}

impl Parser {
    fn new(source: &str) -> Parser {
        let scanner = Scanner::new(source);
        let current = None;
        let grouping_marks = vec![];
        Parser {
            scanner,
            current,
            grouping_marks,
        }
    }

    pub fn parse(source: &str) -> Result<Arc<RwLock<ParsedRegexp>>, String> {
        // parse source string into a `ParsedRegexp` object
        Parser::new(source).parse_source()
    }

    // Attempt to parse source string
    fn parse_source(&mut self) -> Result<Arc<RwLock<ParsedRegexp>>, String> {
        // Grab the first token in stream
        self.advance()?;
        match self.parse_expression() {
            // A syntax error occurred while parsing source string
            Err(error) => Err(error),

            // Successfully parsed source string
            Ok(option_regexp) => {
                // `option_regexp` has type Option<Arc<RwLock<ParsedRegexp>>>
                match option_regexp {
                    Some(regexp) => {
                        // Return the Arc itself otherwise it will dropped making direct child of
                        // root expression hold invalid Weak references to their parent (root itself)
                        Ok(regexp)
                    }
                    None => {
                        // Could not parse source string for some unknown reason
                        // maybe a bug in code
                        // Because even an empty source string has at least one
                        // token, namely Empty, thus we can parse a ParsedRegexp
                        // with its `tag` field set to ExpressionTag::EmptyExpression
                        report_fatal_error(&format!(
                            "Could not parse source string `{}`\n",
                            self.scanner.get_source_string()
                        ))
                    }
                }
            }
        }
    }

    // ParsedRegexp => Concatenation ( "|" Concatenation )*
    fn parse_expression(&mut self) -> Result<Option<Arc<RwLock<ParsedRegexp>>>, String> {
        match self.current {
            None => {
                // Reached end of input, no expression can be parsed
                Ok(None)
            }
            Some(token) => {
                // There are unprocessed tokens
                match token.type_name {
                    // This token can begin a valid expression
                    TokenType::Empty
                    | TokenType::Dot { .. }
                    | TokenType::Character { .. }
                    | TokenType::LeftParen => {
                        // Attempt to parse an arbitrary expression
                        // But do that attempt to parse an alternation expression
                        // because alternation has the lowest precedence of all regular expressions operations
                        let mut alternation_pattern = String::new();
                        let mut alternation = ParsedRegexp::new(ExpressionType::Alternation);

                        // First, attempt to parse one concatenation
                        if let Some(concatenation) = self.parse_concatenation()? {
                            // Parsed first concatenation
                            // Append its pattern
                            alternation_pattern
                                .push_str(&format!("{}|", concatenation.read().unwrap().pattern));
                            alternation.children.write().unwrap().push(concatenation);

                            // As long as current token is |, keep parsing concatenations
                            while self.check(TokenType::Pipe) {
                                // Move past current |
                                self.advance()?;
                                if let Some(expression) = self.parse_concatenation()? {
                                    // Parsed a new expression
                                    // Append its pattern
                                    alternation_pattern.push_str(&format!(
                                        "{}|",
                                        expression.read().unwrap().pattern
                                    ));
                                    // append it to field `children` of this `alternation`
                                    alternation.children.write().unwrap().push(expression);
                                }
                            }
                        }

                        // Can't use `alternation.children.read().unwrap().len()` directly with `match`
                        // because `alternation` is moved inside `match` body
                        let parsed_expressions = alternation.children.read().unwrap().len();
                        match parsed_expressions {
                            0 => {
                                // No expression was parsed, possibly end of pattern
                                Ok(None)
                            }
                            1 => {
                                // One expression was parsed, but alternation expressions are composed
                                // of at least two expressions, thus it makes no sense to return this single
                                // expression as an alternation
                                // Return this expression verbatim
                                Ok(alternation.children.write().unwrap().pop())
                            }
                            _ => {
                                // Remove trailing |
                                alternation_pattern.pop();

                                // At least two expressions were parsed
                                // Composed an alternation expression
                                // Its children are already inside it, in ParsedRegexp field `children`
                                alternation.pattern = Arc::from(alternation_pattern);
                                let alternation = Arc::new(RwLock::new(alternation));
                                alternation
                                    .write()
                                    .unwrap()
                                    .children
                                    .write()
                                    .unwrap()
                                    .iter_mut()
                                    .for_each(|child| {
                                        // Make each child obtain a weak reference to its parent `alternation`
                                        child.write().unwrap().parent =
                                            Some(Arc::downgrade(&alternation));
                                    });

                                // Successfully parsed an alternation expression
                                Ok(Some(alternation))
                            }
                        }
                    }
                    _ => {
                        // Any token which can not begin a valid expression, like + or *
                        let source = self.scanner.get_source_string();
                        let error_char = &source[token.position..=token.position];
                        let error = format!("Expected expression before {error_char}");
                        let (error_index, error_position) = {
                            match self.current {
                                Some(Token { position, .. }) => {
                                    (position, format!("in position {position}"))
                                }
                                None => (source.len(), String::from("at end of pattern")), // in case parser reached end of input
                            }
                        };
                        Err(format_error(
                            &format!("Syntax error {error_position}: {error}"),
                            &source,
                            &[(error_index, 1_u8)],
                            "",
                        ))
                    }
                }
            }
        }
    }

    // Concatenation => Primary+
    fn parse_concatenation(&mut self) -> Result<Option<Arc<RwLock<ParsedRegexp>>>, String> {
        // Attempt to parse a concatenation of regular expressions

        let mut concatenation_pattern = String::new();
        let mut concatenation = ParsedRegexp::new(ExpressionType::Concatenation);
        while let Some(primary_expression) = self.parse_primary()? {
            // Parsed a new expression
            // Append its pattern
            concatenation_pattern.push_str(&primary_expression.read().unwrap().pattern);
            // append it to field `children` of this `alternation`
            concatenation
                .children
                .write()
                .unwrap()
                .push(primary_expression);
        }

        // Can't use `concatenation.children.read().unwrap().len()` directly with `match`
        // because `concatenation` is moved inside `match` body
        let parsed_expressions = concatenation.children.read().unwrap().len();
        match parsed_expressions {
            0 => {
                // No expression was parsed, possibly end of pattern
                Ok(None)
            }
            1 => {
                // One expression was parsed, but concatenation expressions are composed
                // of at least two expressions, thus it makes no sense to return this single
                // expression as a concatenation
                // Return this expression verbatim
                Ok(concatenation.children.write().unwrap().pop())
            }
            _ => {
                // At least two expressions were parsed
                // Composed a concatenation expression
                // Its children are already inside it, in ParsedRegexp field `children`
                concatenation.pattern = Arc::from(concatenation_pattern);
                let concatenation = Arc::new(RwLock::new(concatenation));
                concatenation
                    .write()
                    .unwrap()
                    .children
                    .write()
                    .unwrap()
                    .iter_mut()
                    .for_each(|child| {
                        // Make each child obtain a weak reference to its parent `concatenation`
                        child.write().unwrap().parent = Some(Arc::downgrade(&concatenation));
                    });

                // Successfully parsed a concatenation expression
                Ok(Some(concatenation))
            }
        }
    }

    // Primary => Empty | Group | MatchCharacter | MatchAnyCharacter
    fn parse_primary(&mut self) -> Result<Option<Arc<RwLock<ParsedRegexp>>>, String> {
        // WHAT DO YOU DO `parse_primary`?
        // I parse primary expressions, which are:
        // - The empty regular expression
        // - The dot expression `.`
        // - Character expressions like `x`
        // - Grouped regular expressions, like `(abc)`

        match self.current {
            Some(token) => {
                match &token.type_name {
                    TokenType::Empty => self.parse_empty_expression(),
                    TokenType::Dot => self.parse_dot_expression(),
                    TokenType::Character { value, .. } => self.parse_character_expression(*value),
                    TokenType::LeftParen => self.parse_group(),
                    _ => Ok(None), // Current token can begin a valid expression
                }
            }
            None => Ok(None), // End of pattern
        }
    }

    // Group => "(" ParsedRegexp ")"
    fn parse_group(&mut self) -> Result<Option<Arc<RwLock<ParsedRegexp>>>, String> {
        // Attempt to:
        // First : parse an arbitrary expression
        // Second: After `First` is finished, search for a )
        // If either `First` or `Second` fails, report an error as follow:
        // `First` failed : report error `Expected expression after (`
        // `Second` failed: report error `Expected ) after expression`
        // These rules are due to grammar rule: Group => "(" ParsedRegexp ")"
        // First : After `(` parser expects a `ParsedRegexp`
        // Second: After `ParsedRegexp` parser expects a `)`

        // Move past opening (
        self.advance()?;

        // parse an arbitrary expression or report error (? operator)
        match self.parse_expression()? {
            Some(parsed_expression) => {
                // `parsed_expression` has type Arc<RwLock<ParsedRegexp>>

                // Advance only when current item has name TokenName::RightParent
                // or report error `Expected ) after expression` (? operator)
                self.consume(TokenType::RightParen, "Expected ) after expression")?;
                // field `current` now points to the first character (or Empty token)
                // after the closing )

                // Consume group quantifier (if any)
                let quantifier = self.consume_quantifier()?;
                // Construct parsed grouped expression
                let mut group = ParsedRegexp::new(ExpressionType::Group { quantifier });
                // Surround parsed expression pattern with parentheses
                // to create pattern of this group expression
                group.pattern = {
                    let parsed_expression_pattern = &parsed_expression.read().unwrap().pattern;
                    let group_quantifier = quantifier;
                    Arc::from(format!("({parsed_expression_pattern}){group_quantifier}"))
                };
                // let `group` take ownership of the expression it encloses
                group.children.write().unwrap().push(parsed_expression);
                // convert `group` to appropriate return type
                let group = Arc::new(RwLock::new(group));
                // make enclosed expression `parent` field points to `group`
                group.write().unwrap().children.write().unwrap()[0]
                    .write()
                    .unwrap()
                    .parent = Some(Arc::downgrade(&group));

                // Successfully parsed a grouped expression
                Ok(Some(group))
            }
            None => {
                // Syntax error: Expected expression after (
                // But why? parser call `parse_group` only when
                // its field `current` has type (field `name` in struct Token) is
                // `TokenName::LeftParen`
                // In other words, what the parser currently process is a (
                // it makes sense to attempt to parse a grouped expression
                // because that's what the grammar rule `Group => "(" ParsedRegexp ")"` says
                // So when the parser follows what the grammar says and fails
                // it's a syntax error you made
                let error = "Expected expression after (";
                let source = self.scanner.get_source_string();
                let (error_index, error_position) = {
                    match self.current {
                        Some(Token { position, .. }) => {
                            (position, format!("in position {position}"))
                        }
                        None => (source.len(), String::from("at end of pattern")), // in case parser reached end of input
                    }
                };
                Err(format_error(
                    &format!("Syntax error {error_position}: {error}"),
                    &source,
                    // Place one (1_u8) caret `^` below error position
                    // in source string as a visual aid
                    &[(error_index, 1_u8)],
                    "", // Hints
                ))
            }
        }
    }

    // Empty => ""
    fn parse_empty_expression(&mut self) -> Result<Option<Arc<RwLock<ParsedRegexp>>>, String> {
        // Move past Empty token
        self.advance()?;
        // field `current` now points to the first character after
        // the position of Empty we had before the above call
        // to `advance`. Note that it can not point to another
        // Empty token because the scanner never generates
        // two or more Empty tokens in row

        let mut expr = ParsedRegexp::new(ExpressionType::EmptyExpression);
        // Empty string pattern for the empty expression
        expr.pattern = Arc::from("");

        // Successfully parsed an empty expression
        Ok(Some(Arc::new(RwLock::new(expr))))
    }

    // MatchAnyCharacter => Dot
    fn parse_dot_expression(&mut self) -> Result<Option<Arc<RwLock<ParsedRegexp>>>, String> {
        // Move past Dot token
        self.advance()?;

        let value = None;
        let quantifier = self.consume_quantifier()?;
        let mut expr = ParsedRegexp::new(ExpressionType::CharacterExpression { value, quantifier });
        // A dot for dot expressions succeeded with a quantifier (if any)
        expr.pattern = Arc::from(format!(".{quantifier}").as_str());

        // Successfully parsed a dot expression
        Ok(Some(Arc::new(RwLock::new(expr))))
    }

    // Character => OrdinaryCharacter | EscapedMetacharacter
    fn parse_character_expression(
        &mut self,
        value: char,
    ) -> Result<Option<Arc<RwLock<ParsedRegexp>>>, String> {
        // Move past `Character` token
        self.advance()?;

        let quantifier = self.consume_quantifier()?;
        let mut expr = ParsedRegexp::new(ExpressionType::CharacterExpression {
            value: Some(value),
            quantifier,
        });

        // Use given character for this character expression succeeded with a quantifier (if any)
        expr.pattern = Arc::from(format!("{value}{quantifier}").as_str());

        // Successfully parsed a character expression
        Ok(Some(Arc::new(RwLock::new(expr))))
    }

    // Read next token in stream
    fn advance(&mut self) -> Result<(), String> {
        self.current = self.scanner.next();
        if self.check(TokenType::RightParen) && self.grouping_marks.pop().is_none() {
            // There is no group expression currently processed
            // Thus ) was used without its matching (
            // Syntax error!
            let error = "Unbalanced )\n) is used without a matching (";
            let source = self.scanner.get_source_string();
            let (error_index, error_position) = {
                match self.current {
                    Some(Token { position, .. }) => (position, format!("in position {position}")),
                    None => (source.len(), String::from("at end of pattern")), // in case parser reached end of input
                }
            };
            return Err(format_error(
                &format!("Syntax error {error_position}: {error}"),
                &source,
                // Place one (1_u8) caret `^` below error position
                // in source string as a visual aid
                &[(error_index, 1_u8)],
                // Hints
                "\nTo match a literal ) use \\)\n\
                To match a metacharacter, precede it with a slash in your pattern \\\n\
                To match a *, for instance, use \\* in your pattern\n\n\
                But remember, \\\\ inside your (rust non-raw string) pattern is one slash for the regular expressions engine\n\
                Hence to match a single literal slash, you write pattern \\\\\\\\\n\
                The first pair (one slash, operator) escape the second pair (one slash, operand)\n\
                Or, you can use a raw string r\"\\\\\"",
            ));
        }
        if self.check(TokenType::LeftParen) {
            // The parser has found a possibly opening (
            // Note the word `possibly`, if pattern ends with a matching )
            // then the parser will report a syntax error
            self.grouping_marks.push(GroupingMark::Group {
                position: self.current.unwrap().position,
            });
            return Ok(());
        }

        Ok(())
    }

    // Check if current token (if any) has a given type
    fn check(&self, expected: TokenType) -> bool {
        match self.current {
            Some(token) => token.type_name == expected,
            None => false,
        }
    }

    // Check if current token (if any) has a given type
    // if true then advance
    // if false report `error`
    fn consume(&mut self, expected: TokenType, error: &str) -> Result<(), String> {
        if !self.check(expected) {
            // current token name (type) is not what was expected
            // in other words, grammar requires a specific item to appear here
            // but parser found something else
            // this is a syntax error
            let source = self.scanner.get_source_string();
            let (error_index, error_position) = {
                match self.current {
                    Some(Token { position, .. }) => (position, format!("in position {position}")),
                    None => (source.len(), String::from("at end of pattern")), // in case parser reached end of input
                }
            };
            return Err(format_error(
                &format!("Syntax error {error_position}: {error}"),
                &self.scanner.get_source_string(),
                // Place one (1_u8) caret `^` below error position
                // in source string as a visual aid
                &[(error_index, 1_u8)],
                "", // Hints
            ));
        }
        self.advance()?;
        Ok(())
    }

    fn consume_quantifier(&mut self) -> Result<Quantifier, String> {
        // Check current token, if its name (field `name`) is either one of:
        // Mark, Star, Plus
        // Consume each and construct a Quantifier variant
        let quantifier = {
            match self.current {
                Some(tok) => {
                    // I do not want `cargo fmt` remove the outer block
                    match tok.type_name {
                        TokenType::Mark => Quantifier::ZeroOrOne,
                        TokenType::Star => Quantifier::ZeroOrMore,
                        TokenType::Plus => Quantifier::OneOrMore,
                        _ => Quantifier::None,
                    }
                }
                None => Quantifier::None,
            }
        };
        if !matches!(quantifier, Quantifier::None) {
            // We found a quantifier, consume it
            self.advance()?;
        }
        Ok(quantifier)
    }
}
